
# coding: iso-8859-1 -*-

#https://chat.openai.com/share/e49d0cab-3eff-4802-a8cd-9cca4cd6ba3f

'''
Le but du programme consiste à apprendre au superviseur et au 3 traitants 
à se déplacer dans la grille en respectant les règles suivantes :
- Le superviseur affecte une sous-zone à chacun des 3 traitants ;
- Pour chaque sous-zone qui lui est affecté, le traitant visite chacune des croix contenues dans la sous-zone ;
- Une fois que les traitants ont fini de visiter les croix de leur sous-zones, le superviseur doit se rendre au 
centre de chaque sous-zone ;
- Après s’être rendu au centre des sous-zones traitées par les 3 traitants, le superviseur affecte une nouvelle 
sous-zone à chacun des 3 traitants, le tout en progressant de gauche à droite afin que toutes les croix de la 
grille soient visitées.
'''


import numpy as np
import gymnasium as gym
from gymnasium import spaces
import pygame
import sys
import random

# Ajoutez ces importations en haut de votre fichier
from pygame.locals import QUIT


class MobileSupervisor:
    def __init__(self):
        # Initialisation de la classe MobileSupervisor
        self._supervisor_x = None 
        self._supervisor_y = None
    
    def get_x_pos(self):
        return self._supervisor_x
        
    def get_y_pos(self):
        return self._supervisor_y

    def set_x_pos(self, nouvelle_valeur):
        self._supervisor_x = nouvelle_valeur

    def set_y_pos(self, nouvelle_valeur):
        self._supervisor_y = nouvelle_valeur
    
    def moveTo(self):
        # Méthode de la classe MobileSupervisor
        pass

    def doThis(self):
        # Méthode de la classe MobileSupervisor
        pass

    def doThat(self):
        # Méthode de la classe MobileSupervisor
        pass

class MobileOperator:
    def __init__(self):
        # Initialisation de la classe MobileOperator
        self._supervisor_x = None 
        self._supervisor_y = None
    
    def get_x_pos(self):
        return self._supervisor_x
        
    def get_y_pos(self):
        return self._supervisor_y

    def set_x_pos(self, nouvelle_valeur):
        self._supervisor_x = nouvelle_valeur

    def set_y_pos(self, nouvelle_valeur):
        self._supervisor_y = nouvelle_valeur

    def moveTo(self):
        # Méthode de la classe MobileOperator
        pass

    def doThis(self):
        # Méthode de la classe MobileOperator
        pass

    def doThat(self):
        # Méthode de la classe MobileOperator
        pass

class PygameEnv:
    def __init__(self):
        # Initialisation de la classe MobileSupervisor
        pass
     
    # Fonction pour dessiner les sous-zones en damier
    def draw_subzones(self, pygame, fenetre, vert, jaune, num_subzones_grid_height, centres_sous_zones, plage_coords, subzones_width, taille_case_x, taille_case_y ):
        couleur1 = jaune 
        couleur2 = vert
           
        for i, centre in enumerate(centres_sous_zones):
        
            if i % 2 == 0 : couleur = couleur1  
            else : couleur = couleur2
            
            for dx in range(plage_coords[0], plage_coords[subzones_width -1] + 1):
                for dy in range(plage_coords[0], plage_coords[subzones_width -1] + 1):
                    x = centre[0] + dx
                    y = centre[1] + dy
                    pygame.draw.rect(fenetre, couleur, (x * taille_case_x, y * taille_case_y, taille_case_x, taille_case_y))
                     
            multiple = (i+1) % num_subzones_grid_height
            if multiple == 0  :
                temp = couleur1
                couleur1 = couleur2 
                couleur2 = temp
         
                  
    # Fonction pour dessiner les sous-zones visités
    def draw_visited_subzones(self, pygame, fenetre, orange, centres_sous_zones_visitees, plage_coords, subzones_width, taille_case_x, taille_case_y ):
        
        for centre in centres_sous_zones_visitees:
            for dx in range(plage_coords[0], plage_coords[subzones_width -1] + 1):
                for dy in range(plage_coords[0], plage_coords[subzones_width -1] + 1):
                    x = centre[0] + dx
                    y = centre[1] + dy
                    pygame.draw.rect(fenetre, orange, (x * taille_case_x, y * taille_case_y, taille_case_x, taille_case_y))
                
            
    # Fonction pour dessiner la grille
    def draw_grid(self, pygame, fenetre, noir, hauteur_fenetre, largeur_fenetre, taille_case_x, taille_case_y):
        for x in range(0, largeur_fenetre, taille_case_x):
            pygame.draw.line(fenetre, noir, (x, 0), (x, hauteur_fenetre))
        for y in range(0, hauteur_fenetre, taille_case_y):
            pygame.draw.line(fenetre, noir, (0, y), (largeur_fenetre, y))

    
    # Fonction pour dessiner le supervisor
    def draw_supervisor(self,pygame, fenetre, bleu_clair, mobileSupervisor, taille_case_x, taille_case_y ):
        pygame.draw.rect(fenetre, bleu_clair, (mobileSupervisor.get_x_pos() * taille_case_x, mobileSupervisor.get_y_pos() * taille_case_y, taille_case_x, taille_case_y))
    
    
    # Fonction pour dessiner les operators
    def draw_operators(self, pygame, fenetre, bleu_fonce, mobileOperators, taille_case_x, taille_case_y):
        for i in range(len(mobileOperators)):
            pygame.draw.rect(fenetre, bleu_fonce, (mobileOperators[i].get_x_pos() * taille_case_x, mobileOperators[i].get_y_pos() * taille_case_y, taille_case_x, taille_case_y))
            
    # Fonction pour dessiner une croix
    def draw_crosses(self, pygame, fenetre, rouge, croix, taille_case_x, taille_case_y):
        for x, y in croix:
            x_pos = x * taille_case_x + taille_case_x // 2
            y_pos = y * taille_case_y + taille_case_y // 2

            pygame.draw.line(fenetre, rouge, (x_pos - 10, y_pos - 10), (x_pos + 10, y_pos + 10), 2)
            pygame.draw.line(fenetre, rouge, (x_pos + 10, y_pos - 10), (x_pos - 10, y_pos + 10), 2)


           

# Définition de l'environnement du problème
class MultiAgentsSupervisorWorkersEnv(gym.Env):
    def __init__(self, config):
        # Initialisation de l'environnement avec les paramètres de configuration
        
        self.grid_size = (5, 5)  # Taille de la grille (5x5)
       
        
        self.agent_positions = {
            "superviseur": (0, 0),  # Agent avec le rôle 1 (superviseur) commence en haut à gauche
            "agent_1": (0, 0),     # Agents avec le rôle 2 commencent également en haut à gauche
            "agent_2": (0, 0),
            "agent_3": (0, 0),
        }
        
        
        
        
               
        self.subzones_width = config["subzones_width"]
        centre = self.subzones_width // 2  
        self.plage_coords = [i - centre for i in range(self.subzones_width)] # plage de coordonnées utile pour dessiner les sous-zones
        
        self.num_subzones_grid_width = config["num_boxes_grid_width"] // self.subzones_width
        self.num_subzones_grid_height = config["num_boxes_grid_height"] // self.subzones_width 
        self.num_subzones = self.num_subzones_grid_width * self.num_subzones_grid_height 
        
        self.num_operators = config["num_operators"]
        self.num_directions = config["num_directions"]
        self.num_targets = config["num_targets"]
        
        
        # Créez une instance de la classe MobileSupervisor
        self.mobileSupervisor = MobileSupervisor()
                
        # Créez une liste d'instances de la classe MobileOperator
        self.mobileOperators = [MobileOperator() for _ in range(self.num_operators)]   
        
        
        self.supervisor_visited_subzones = []  # Stocker les sous-zones visitées par le supervisor
        self.operator_visited_points = [[] for _ in range(self.num_operators)]  # Stocker les points visités par chaque operator
        
        
        ############################################################################################
        # Répartissez les subzones entre les travailleurs lors de l'initialisation
        self.operator_subzones = {}
        self.operator_current_subzone = {}

        subzones_per_operator = self.num_subzones // self.num_operators
        remaining_subzones = self.num_subzones

        for operator_idx in range(self.num_operators):
            if remaining_subzones >= subzones_per_operator:
                # Distribuez subzones_per_operator subzones à ce travailleur
                self.operator_subzones[operator_idx] = list(range(operator_idx * subzones_per_operator, (operator_idx + 1) * subzones_per_operator))
                remaining_subzones -= subzones_per_operator
            else:
                # Distribuez les subzones restants à ce travailleur
                self.operator_subzones[operator_idx] = list(range(operator_idx * subzones_per_operator, operator_idx * subzones_per_operator + remaining_subzones))
                remaining_subzones = 0

            # Initialisez le subzone actuel de chaque travailleur à 0
            self.operator_current_subzone[operator_idx] = 0
        ############################################################################################    
           




        ############################################################################################   
        # Espace d'action 
        self.action_space = spaces.Box(low=-1, high=1, shape=(2,), dtype=np.float32)  # Déplacement en 2D
        
        # Espaces d'observation pour le supervisor
        self.supervisor_observation_space = spaces.Box(low=0, high=1, shape=(2,), dtype=np.float32)
        
        # Espaces d'observation pour les operators
        self.operator_observation_space = spaces.Box(low=0, high=1, shape=(2,), dtype=np.float32)
        ############################################################################################
        
        
        
        
        
        
        ############################################################################################
        # Dimensions de la fenêtre pygame
        self.largeur_fenetre = config["num_boxes_grid_width"] * 40
        self.hauteur_fenetre = config["num_boxes_grid_height"] * 40

        # Taille de la grille
        self.largeur_grille = config["num_boxes_grid_width"] #Nombre de colonnes de la grille
        self.hauteur_grille = config["num_boxes_grid_height"]  #Nombre de lignes de la grille
        
        
        self.goal_positions = {
            "superviseur": (self.largeur_grille - 1, 0),  # Objectif du superviseur : coin supérieur droit
            "agent_1": (self.largeur_grille - 1, self.hauteur_grille - 1),  # Objectif des agents 1, 2 et 3 : coin inférieur droit
            "agent_2": (self.largeur_grille - 1, self.hauteur_grille - 1),
            "agent_3": (self.largeur_grille - 1, self.hauteur_grille - 1),
        }
        
        
        

        # Taille de la case
        self.taille_case_x = self.largeur_fenetre // self.largeur_grille
        self.taille_case_y = self.hauteur_fenetre // self.hauteur_grille

        # Initialisation de la liste de coordonnées des centres des sous-zones jaunes et vertes
        self.centres_sous_zones = []
        pas = config["subzones_width"]
        # Boucles pour générer les coordonnées
        for x in range(1, self.largeur_grille, pas):
            for y in range(1, self.hauteur_grille, pas):
                self.centres_sous_zones.append((x, y))
                
                
        # Initialisation de la liste de coordonnées des sous-zones visitées pour l'exemple        
        self.centres_sous_zones_visitees = [] 
        self.centres_sous_zones_visitees = self.centres_sous_zones[0:2]
        

        # Position du supervisor à l'itération 0
        self.mobileSupervisor.set_x_pos(0)
        self.mobileSupervisor.set_y_pos(0)
       
        # Positions des operators à l'itération 0
        for i in range(self.num_operators):
            self.mobileOperators[i].set_x_pos(0)
            self.mobileOperators[i].set_y_pos(0)   
            
        

        # Liste de croix représentant la case où se trouvent les cibles
        self.croix = []
        # Générer 60 croix aléatoirement
        for _ in range(self.num_targets):
            x = random.randint(0, self.largeur_grille - 1)
            y = random.randint(0, self.hauteur_grille - 1)
            self.croix.append((x, y)) 
        ############################################################################################    

    def reset(self):
        # Réinitialisation de la position des agents
        # Position du supervisor à l'itération 0
        self.mobileSupervisor.set_x_pos(0)
        self.mobileSupervisor.set_y_pos(0)
       
        # Positions des operators à l'itération 0
        for i in range(self.num_operators):
            self.mobileOperators[i].set_x_pos(0)
            self.mobileOperators[i].set_y_pos(0) 
               
        
        return self._get_observation()

    def step(self, action_dict):
        # Déplacement des agents en fonction de l'action
        for agent, action in action_dict.items():
            if action == 0:  # Haut
                self.agent_positions[agent] = (max(0, self.agent_positions[agent][0] - 1), self.agent_positions[agent][1])
            elif action == 1:  # Bas
                self.agent_positions[agent] = (min(self.grid_size[0] - 1, self.agent_positions[agent][0] + 1), self.agent_positions[agent][1])
            elif action == 2:  # Gauche
                self.agent_positions[agent] = (self.agent_positions[agent][0], max(0, self.agent_positions[agent][1] - 1))
            elif action == 3:  # Droite
                self.agent_positions[agent] = (self.agent_positions[agent][0], min(self.grid_size[1] - 1, self.agent_positions[agent][1] + 1))

        # Calcul des récompenses
        rewards = {}
        dones = {}

        for agent in self.agent_positions.keys():
            if self.agent_positions[agent] == self.goal_positions[agent]:
                rewards[agent] = 1.0
                dones[agent] = True
            else:
                rewards[agent] = 0.0
                dones[agent] = False

        return self._get_observation(), rewards, dones, {}
        
    def _get_observation(self):
        # L'observation dépend de la position actuelle de chaque agent
        observations = {}
        for agent, position in self.agent_positions.items():
            observations[agent] = 0 if position == self.goal_positions[agent] else 1
        
        return observations     
       
        
    # Dans la classe MultiAgentClusterEnv, modifiez la méthode render pour afficher la grille, les robots, les points et les subzones
    def render(self):
        # Initialisation de Pygame
        pygame.init()
        
        pygameEnv = PygameEnv()

        # Création de la fenêtre
        fenetre = pygame.display.set_mode((self.largeur_fenetre, self.hauteur_fenetre))
        pygame.display.set_caption("Multi-Agent Supervisor Workers Environment")
        
        # Couleurs
        blanc = (255, 255, 255)
        noir = (0, 0, 0)
        bleu_clair = (173, 216, 230)
        bleu_fonce = (0, 0, 128)
        rouge = (255, 0, 0)
        jaune = (255, 255, 0)
        vert = (0, 255, 0)
        orange = (255, 128, 0)
        
        clock = pygame.time.Clock()

        while True:
            for event in pygame.event.get():
                if event.type == QUIT:
                    pygame.quit()
                    sys.exit()
            
            if self.num_directions == 4 :
                # Déplacement aléatoire du supervisor
                direction_supervisor = random.choice(["up", "down", "left", "right"])
                supervisor_y = self.mobileSupervisor.get_y_pos()
                supervisor_x = self.mobileSupervisor.get_x_pos()
                if direction_supervisor == "up" and supervisor_y > 0:
                    self.mobileSupervisor.set_y_pos(supervisor_y -1) 
                elif direction_supervisor == "down" and supervisor_y < self.hauteur_grille - 1:
                    self.mobileSupervisor.set_y_pos(supervisor_y + 1)
                elif direction_supervisor == "left" and supervisor_x > 0:
                    self.mobileSupervisor.set_x_pos(supervisor_x - 1)
                elif direction_supervisor == "right" and supervisor_x < self.largeur_grille - 1:
                    self.mobileSupervisor.set_y_pos(supervisor_x + 1)

                # Déplacement aléatoire des operators
                for i in range(self.num_operators):
                    direction_operator = random.choice(["up", "down", "left", "right"])
                    operator_x = self.mobileOperators[i].get_x_pos()
                    operator_y = self.mobileOperators[i].get_y_pos()
                    if direction_operator == "up" and operator_y > 0:
                        self.mobileOperators[i].set_y_pos(operator_y - 1)
                    elif direction_operator == "down" and operator_y < self.hauteur_grille - 1:
                        self.mobileOperators[i].set_y_pos(operator_y + 1)
                    elif direction_operator == "left" and operator_x > 0:
                        self.mobileOperators[i].set_x_pos(operator_x - 1)
                    elif direction_operator == "right" and operator_x < self.largeur_grille - 1:
                        self.mobileOperators[i].set_x_pos(operator_x + 1)
            
            elif self.num_directions == 8:
                # Déplacement aléatoire du supervisor
                direction_supervisor = random.choice(["up", "down", "left", "right", "diag_sup_left", "diag_sup_right", "diag_sup_left", "diag_sup_right"])
                supervisor_y = self.mobileSupervisor.get_y_pos()
                supervisor_x = self.mobileSupervisor.get_x_pos()
                if direction_supervisor == "up" and supervisor_y > 0:
                    self.mobileSupervisor.set_y_pos(supervisor_y -1) 
                elif direction_supervisor == "down" and supervisor_y < self.hauteur_grille - 1:
                    self.mobileSupervisor.set_y_pos(supervisor_y + 1)
                elif direction_supervisor == "left" and supervisor_x > 0:
                    self.mobileSupervisor.set_x_pos(supervisor_x - 1)
                elif direction_supervisor == "right" and supervisor_x < self.largeur_grille - 1:
                    self.mobileSupervisor.set_y_pos(supervisor_x + 1)
                elif direction_supervisor == "diag_sup_left" and (supervisor_x > 0) and (supervisor_y > 0):
                    self.mobileSupervisor.set_x_pos(supervisor_x - 1)
                    self.mobileSupervisor.set_y_pos(supervisor_y - 1)
                elif direction_supervisor == "diag_sup_right" and (supervisor_x < self.largeur_grille - 1) and (supervisor_y > 0):
                    self.mobileSupervisor.set_x_pos(supervisor_x + 1)
                    self.mobileSupervisor.set_y_pos(supervisor_y - 1)
                elif direction_supervisor == "diag_inf_left" and (supervisor_x > 0) and (supervisor_y < self.hauteur_grille - 1):
                    self.mobileSupervisor.set_x_pos(supervisor_x - 1)
                    self.mobileSupervisor.set_y_pos(supervisor_y + 1)
                elif direction_supervisor == "diag_inf_right" and (supervisor_x < self.largeur_grille - 1) and (supervisor_y < self.hauteur_grille - 1):
                    self.mobileSupervisor.set_x_pos(supervisor_x + 1)
                    self.mobileSupervisor.set_y_pos(supervisor_y + 1)
                        
                        
                # Déplacement aléatoire des operators
                for i in range(self.num_operators):
                    direction_operator = random.choice(["up", "down", "left", "right", "diag_sup_left", "diag_sup_right", "diag_inf_left", "diag_inf_right"])
                    operator_x = self.mobileOperators[i].get_x_pos()
                    operator_y = self.mobileOperators[i].get_y_pos()
                    if direction_operator == "up" and operator_y > 0:
                        self.mobileOperators[i].set_y_pos(operator_y - 1)
                    elif direction_operator == "down" and operator_y < self.hauteur_grille - 1:
                        self.mobileOperators[i].set_y_pos(operator_y + 1)
                    elif direction_operator == "left" and operator_x > 0:
                        self.mobileOperators[i].set_x_pos(operator_x - 1)
                    elif direction_operator == "right" and operator_x < self.largeur_grille - 1:
                        self.mobileOperators[i].set_x_pos(operator_x + 1)
                    elif direction_operator == "diag_sup_left" and (operator_x > 0) and (operator_y > 0):
                        self.mobileOperators[i].set_x_pos(operator_x - 1)
                        self.mobileOperators[i].set_y_pos(operator_y - 1)
                    elif direction_operator == "diag_sup_right" and (operator_x < self.largeur_grille - 1) and (operator_y > 0):
                        self.mobileOperators[i].set_x_pos(operator_x + 1)
                        self.mobileOperators[i].set_y_pos(operator_y - 1)
                    elif direction_operator == "diag_inf_left" and (operator_x > 0) and (operator_y < self.hauteur_grille - 1):
                        self.mobileOperators[i].set_x_pos(operator_x - 1)
                        self.mobileOperators[i].set_y_pos(operator_y + 1)
                    elif direction_operator == "diag_inf_right" and (operator_x < self.largeur_grille - 1) and (operator_y < self.hauteur_grille - 1):
                        self.mobileOperators[i].set_x_pos(operator_x + 1)
                        self.mobileOperators[i].set_y_pos(operator_y + 1)
            
            
            
            # Efface la fenêtre
            fenetre.fill(blanc)
            
            # Dessine les sous-zones en damier
            pygameEnv.draw_subzones(pygame, fenetre, vert, jaune, self.num_subzones_grid_height, self.centres_sous_zones, self.plage_coords, self.subzones_width, self.taille_case_x, self.taille_case_y )
     
            # Dessine les sous-zones visitées pour l'exemple
            pygameEnv.draw_visited_subzones(pygame, fenetre, orange, self.centres_sous_zones_visitees, self.plage_coords, self.subzones_width, self.taille_case_x, self.taille_case_y )
     
            # Dessine la grille
            pygameEnv.draw_grid(pygame, fenetre, noir, self.hauteur_fenetre, self.largeur_fenetre, self.taille_case_x, self.taille_case_y)

            # Dessine les robots
            pygameEnv.draw_supervisor(pygame, fenetre, bleu_clair, self.mobileSupervisor, self.taille_case_x, self.taille_case_y )
            pygameEnv.draw_operators(pygame, fenetre, bleu_fonce, self.mobileOperators, self.taille_case_x, self.taille_case_y)

            # Dessine les croix
            pygameEnv.draw_crosses(pygame, fenetre, rouge, self.croix, self.taille_case_x, self.taille_case_y)
            
            # Met à jour la fenêtre
            pygame.display.flip()

            # Limite la fréquence de rafraîchissement
            clock.tick(1)

    # Fonction pour dessiner les sous-zones en damier
    def draw_subzones(self, fenetre, vert, jaune ):
        couleur1 = jaune 
        couleur2 = vert
           
        for i, centre in enumerate(self.centres_sous_zones):
        
            if i % 2 == 0 : couleur = couleur1  
            else : couleur = couleur2
            
            for dx in range(self.plage_coords[0], self.plage_coords[self.subzones_width -1] + 1):
                for dy in range(self.plage_coords[0], self.plage_coords[self.subzones_width -1] + 1):
                    x = centre[0] + dx
                    y = centre[1] + dy
                    pygame.draw.rect(fenetre, couleur, (x * self.taille_case_x, y * self.taille_case_y, self.taille_case_x, self.taille_case_y))
                     
            multiple = (i+1) % self.num_subzones_grid_height
            if multiple == 0  :
                temp = couleur1
                couleur1 = couleur2 
                couleur2 = temp
         
            
    # Fonction pour dessiner les sous-zones visités
    def draw_visited_subzones(self, fenetre, orange ):
        for centre in self.centres_sous_zones_visitees:
            for dx in range(self.plage_coords[0], self.plage_coords[self.subzones_width -1] + 1):
                for dy in range(self.plage_coords[0], self.plage_coords[self.subzones_width -1] + 1):
                    x = centre[0] + dx
                    y = centre[1] + dy
                    pygame.draw.rect(fenetre, orange, (x * self.taille_case_x, y * self.taille_case_y, self.taille_case_x, self.taille_case_y))
                
            
    # Fonction pour dessiner la grille
    def draw_grid(self, fenetre, noir):
        for x in range(0, self.largeur_fenetre, self.taille_case_x):
            pygame.draw.line(fenetre, noir, (x, 0), (x, self.hauteur_fenetre))
        for y in range(0, self.hauteur_fenetre, self.taille_case_y):
            pygame.draw.line(fenetre, noir, (0, y), (self.largeur_fenetre, y))

    


       
# Configuration de l'environnement RL
config = {
    "env": MultiAgentsSupervisorWorkersEnv,
    "num_workers": 4,    # Nombre de travailleurs (agents) parallèles
    "num_envs_per_worker": 1,  # Nombre d'environnements par travailleur
    "num_boxes_grid_width":24,
    "num_boxes_grid_height":12,
    "subzones_width":3, 
    "num_operators": 3,
    "num_directions": 8,
    "num_targets":60,
    # Autres paramètres de configuration RL ici
     "num_envs_per_worker": 1,  # Nombre d'environnements par travailleur
    "multiagent": {
        "policies": {
            "superviseur_policy": (None, 1, 1),  # Superviseur (rôle 1)
            "operateur_policy": (None, 3, 1),   # Opérateurs (rôle 2, 3 agents)
        },
        "policy_mapping_fn": lambda agent_id: "superviseur_policy" if agent_id == "superviseur" else "operateur_policy",
        "policies_to_train": ["superviseur_policy", "operateur_policy"],
    },
}


# Initialisation de Ray et de l'entraînement RL
#ray.init()


env = MultiAgentsSupervisorWorkersEnv(config=config)
# Entraînement du modèle RL
for i in range(100):
    result = "trainer.train()"
    print(f"Iteration {i}: {result}")
    env.render()  # Appel de la méthode render pour l'affichage'''
    
    
# Fermeture de Ray
#ray.shutdown()




